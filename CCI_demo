#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
åä¸ºäº‘CCI Namespace APIè°ƒç”¨ç¤ºä¾‹
æ¼”ç¤ºå¦‚ä½•ä½¿ç”¨AK/SKè®¿é—®åä¸ºäº‘CCIæœåŠ¡è·å–æ‰€æœ‰namespace
"""

import copy
import sys
import hashlib
import hmac
import binascii
import requests
import json
from datetime import datetime
from urllib.parse import quote, unquote


def hmacsha256(byte, msg):
    return hmac.new(byte.encode('utf-8'),
                    msg.encode('utf-8'),
                    digestmod=hashlib.sha256).digest()


def urlencode(str):
    return quote(str, safe='~')


def findHeader(req, h):
    for header in req.headers:
        if header.lower() == h.lower():
            return req.headers[header]
    return None


def HexEncodeSHA256Hash(d):
    sha = hashlib.sha256()
    sha.update(d)
    return sha.hexdigest()


class HttpRequest:
    def __init__(self, m="", u="", h=None, b=""):
        self.method = m
        sp = u.split("://", 1)
        s = 'http'
        if len(sp) > 1:
            s = sp[0]
            u = sp[1]
        q = {}
        sp = u.split('?', 1)
        u = sp[0]
        if len(sp) > 1:
            for kv in sp[1].split("&"):
                sp = kv.split("=", 1)
                k = sp[0]
                v = ""
                if len(sp) > 1:
                    v = sp[1]
                if k != '':
                    k = unquote(k)
                    v = unquote(v)
                    if k in q:
                        q[k].append(v)
                    else:
                        q[k] = [v]
        sp = u.split('/', 1)
        host = sp[0]
        if len(sp) > 1:
            u = '/' + sp[1]
        else:
            u = '/'

        self.scheme = s
        self.host = host
        self.uri = u
        self.query = q
        if h is None:
            self.headers = {}
        else:
            self.headers = copy.deepcopy(h)
        self.body = b.encode("utf-8") if isinstance(b, str) else b


DateFormat = "%Y%m%dT%H%M%SZ"
Alg = "SDK-HMAC-SHA256"
HXDate = "X-Sdk-Date"
HHost = "host"
HAuthorization = "Authorization"
HContentSha256 = "x-sdk-content-sha256"


def StringToSign(request, time):
    b = HexEncodeSHA256Hash(request.encode('utf-8'))
    return "%s\n%s\n%s" % (Alg, datetime.strftime(time, DateFormat), b)


def CanonicalRequest(req, sHeaders):
    canonicalHeaders = CanonicalHeaders(req, sHeaders)
    hencode = findHeader(req, HContentSha256)
    if hencode is None:
        hencode = HexEncodeSHA256Hash(req.body)
    return "%s\n%s\n%s\n%s\n%s\n%s" % (req.method.upper(), CanonicalURI(req),
                                       CanonicalQueryString(req),
                                       canonicalHeaders,
                                       ";".join(sHeaders), hencode)


def CanonicalURI(req):
    patterns = unquote(req.uri).split('/')
    uri = []
    for value in patterns:
        uri.append(urlencode(value))
    url_path = "/".join(uri)
    if url_path[-1] != '/':
        url_path = url_path + "/"
    return url_path


def CanonicalQueryString(req):
    keys = []
    for key in req.query:
        keys.append(key)
    keys.sort()
    arr = []
    for key in keys:
        ke = urlencode(key)
        value = req.query[key]
        if type(value) is list:
            value.sort()
            for v in value:
                kv = ke + "=" + urlencode(str(v))
                arr.append(kv)
        else:
            kv = ke + "=" + urlencode(str(value))
            arr.append(kv)
    return '&'.join(arr)


def CanonicalHeaders(req, sHeaders):
    arr = []
    _headers = {}
    for k in req.headers:
        keyEncoded = k.lower()
        value = req.headers[k]
        valueEncoded = value.strip()
        _headers[keyEncoded] = valueEncoded
        req.headers[k] = valueEncoded.encode("utf-8").decode('iso-8859-1')
    for k in sHeaders:
        arr.append(k + ":" + _headers[k])
    return '\n'.join(arr) + "\n"


def SignedHeaders(req):
    arr = []
    for k in req.headers:
        arr.append(k.lower())
    arr.sort()
    return arr


def SignStringToSign(strToSign, sigKey):
    hmac_digest = hmacsha256(sigKey, strToSign)
    return binascii.hexlify(hmac_digest).decode()


def AuthHeaderValue(sig, AppKey, sHeaders):
    return "%s Access=%s, SignedHeaders=%s, Signature=%s" % (
        Alg, AppKey, ";".join(sHeaders), sig)


class Signer:
    def __init__(self):
        self.Key = ""
        self.Secret = ""

    def Sign(self, req):
        if isinstance(req.body, str):
            req.body = req.body.encode('utf-8')
        
        headerTime = findHeader(req, HXDate)
        if headerTime is None:
            time = datetime.utcnow()
            req.headers[HXDate] = datetime.strftime(time, DateFormat)
        else:
            time = datetime.strptime(headerTime, DateFormat)

        haveHost = False
        for key in req.headers:
            if key.lower() == 'host':
                haveHost = True
                break
        if not haveHost:
            req.headers["host"] = req.host
        req.headers["content-length"] = str(len(req.body))
        
        queryString = CanonicalQueryString(req)
        if queryString != "":
            req.uri = req.uri + "?" + queryString
            
        signedHeaders = SignedHeaders(req)
        canonicalRequest = CanonicalRequest(req, signedHeaders)
        stringToSign = StringToSign(canonicalRequest, time)
        signature = SignStringToSign(stringToSign, self.Secret)
        authValue = AuthHeaderValue(signature, self.Key, signedHeaders)
        req.headers[HAuthorization] = authValue


def get_cci_namespaces(access_key, secret_key, region):
    """
    è·å–åä¸ºäº‘CCIæ‰€æœ‰namespace
    """
    # æ ¹æ®åä¸ºäº‘å®˜æ–¹æ–‡æ¡£ï¼ŒCCI APIç«¯ç‚¹æ ¼å¼ä¸ºï¼šcci.{region}.myhuaweicloud.com
    # åŒæ—¶æ·»åŠ ä¸€äº›è°ƒè¯•ä¿¡æ¯
    print(f"ğŸ” æ­£åœ¨ä½¿ç”¨åŒºåŸŸ: {region}")
    print(f"ğŸ”‘ è®¿é—®å¯†é’¥ID: {access_key[:8]}...")
    
    possible_urls = [
        f"https://cci.{region}.myhuaweicloud.com/api/v1/namespaces",  # åä¸ºäº‘æ ‡å‡†æ ¼å¼
    ]
    
    for i, url in enumerate(possible_urls, 1):
        print(f"\nå°è¯•ç¬¬{i}ä¸ªç«¯ç‚¹: {url}")
        if try_single_endpoint(url, access_key, secret_key):
            return True
    
    return False


def try_single_endpoint(url, access_key, secret_key):
    """
    å°è¯•å•ä¸ªç«¯ç‚¹
    """
    # åˆ›å»ºHTTPè¯·æ±‚å¯¹è±¡
    request = HttpRequest("GET", url, {}, "")
    
    # åˆ›å»ºç­¾åå™¨
    signer = Signer()
    signer.Key = access_key
    signer.Secret = secret_key
    
    # å¯¹è¯·æ±‚è¿›è¡Œç­¾å
    print(f"å‡†å¤‡ç­¾åè¯·æ±‚...")
    print(f"ç­¾åå‰çš„headers: {request.headers}")
    signer.Sign(request)
    print(f"ç­¾ååçš„headers: {request.headers}")
    
    # å‘é€è¯·æ±‚
    try:
        print(f"å‘é€GETè¯·æ±‚åˆ°: {url}")
        response = requests.get(url, headers=request.headers, timeout=30)
        print(f"å“åº”çŠ¶æ€ç : {response.status_code}")
        
        if response.status_code == 200:
            print(f"âœ… è¯·æ±‚æˆåŠŸï¼")
            print(f"å“åº”å¤´: {dict(response.headers)}")
            
            # æ ¼å¼åŒ–è¾“å‡ºJSONå“åº”
            response_data = response.json()
            print(f"å“åº”å†…å®¹:")
            print(json.dumps(response_data, indent=2, ensure_ascii=False))
            
            # è§£ænamespaceä¿¡æ¯
            if "items" in response_data:
                namespaces = response_data["items"]
                print(f"\næ‰¾åˆ° {len(namespaces)} ä¸ªnamespace:")
                for i, ns in enumerate(namespaces, 1):
                    name = ns.get("metadata", {}).get("name", "Unknown")
                    creation_time = ns.get("metadata", {}).get("creationTimestamp", "Unknown")
                    status = ns.get("status", {}).get("phase", "Unknown")
                    print(f"{i}. åç§°: {name}, çŠ¶æ€: {status}, åˆ›å»ºæ—¶é—´: {creation_time}")
            return True
        else:
            print(f"âŒ è¯·æ±‚å¤±è´¥ï¼ŒçŠ¶æ€ç : {response.status_code}")
            print(f"å“åº”å†…å®¹: {response.text}")
            return False
        
    except requests.exceptions.RequestException as e:
        print(f"âŒ ç½‘ç»œè¯·æ±‚å¼‚å¸¸: {e}")
        return False
    except json.JSONDecodeError as e:
        print(f"âŒ JSONè§£æå¤±è´¥: {e}")
        print(f"åŸå§‹å“åº”: {response.text}")
        return False
    except Exception as e:
        print(f"âŒ æœªçŸ¥é”™è¯¯: {e}")
        return False


def main():
    """
    ä¸»å‡½æ•°
    """
    # åä¸ºäº‘è®¤è¯ä¿¡æ¯ï¼ˆä»ç¯å¢ƒå˜é‡æˆ–ç›´æ¥è®¾ç½®ï¼‰
    access_key = ""
    secret_key = ""
    # æ³¨æ„ï¼šcn-east-4 ä¸æ”¯æŒCCIæœåŠ¡ï¼Œæ”¹ç”¨ cn-north-4
    region = "cn-north-4"  # ååŒ—-åŒ—äº¬å››ï¼Œæ”¯æŒCCIæœåŠ¡
    
    print("åä¸ºäº‘CCI Namespace APIè°ƒç”¨ç¤ºä¾‹")
    print("=" * 50)
    print(f"Region: {region}")
    print(f"Access Key: {access_key[:8]}***")
    print("=" * 50)
    
    # è°ƒç”¨APIè·å–namespaceåˆ—è¡¨
    result = get_cci_namespaces(access_key, secret_key, region)
    
    if result:
        print("\nğŸ‰ æˆåŠŸæ‰¾åˆ°å¯ç”¨çš„CCI APIç«¯ç‚¹å¹¶è·å–åˆ°namespaceä¿¡æ¯ï¼")
    else:
        print("\nâŒ æ‰€æœ‰ç«¯ç‚¹éƒ½æ— æ³•è®¿é—®ï¼Œå¯èƒ½çš„åŸå› :")
        print("   1. ç½‘ç»œè¿æ¥é—®é¢˜")
        print("   2. è®¤è¯ä¿¡æ¯æœ‰è¯¯")
        print("   3. åŒºåŸŸä¸æ”¯æŒCCIæœåŠ¡")
        print("   4. APIç«¯ç‚¹æ ¼å¼å‘ç”Ÿäº†å˜åŒ–")


if __name__ == "__main__":
    main() 
